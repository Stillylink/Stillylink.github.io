<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Анонимный чат — Private</title>
  <link rel="stylesheet" href="/style.css">

  <style>
    /* Локальные правки для страницы чата */
    :root { -webkit-text-size-adjust: 100%; }

    .screen {
      display: none;
      padding: 20px;
    }
    .visible { display: block; }

    #search-screen, #end-screen {
      text-align: center;
    }

    #chat-window {
      display: flex;
      flex-direction: column;
      height: calc(100vh - 100px);
      padding: 10px;
    }

    #messages {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 8px;
      margin-bottom: 10px;
      background: #fff;
    }

    #chatInput {
      display: flex;
      gap: 10px;
    }

    #chatText {
      flex: 1;
      padding: 10px;
      border-radius: 6px;
      border: 1px solid #ccc;
    }

    #sendMessage {
      padding: 10px 15px;
      border-radius: 6px;
      border: none;
      background: #2d72ff;
      color: white;
      cursor: pointer;
    }

    #finishBtn, #newChatBtn, #cancelSearch, #exitBtn {
      padding: 10px 15px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      background: #2d72ff;
      color: #fff;
      margin-top: 15px;
    }

    /* Modal */
    #finishModal.hidden { display: none; }
    #finishModal {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.5);
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #finishModalContent {
      background: white;
      padding: 20px;
      border-radius: 6px;
      text-align: center;
      width: 300px;
    }

    .partner-msg {
      background: #eee;
      padding: 8px 10px;
      margin: 5px 0;
      border-radius: 6px;
      text-align: left;
    }

    .my-msg {
      background: #007aff;
      padding: 8px 10px;
      color: white;
      margin: 5px 0;
      border-radius: 6px;
      text-align: right;
    }
  </style>
</head>
<body>

<header>
  <a href="/anonymous/" id="exitBtn">← Выйти</a>
</header>

<main>

  <!-- SEARCH SCREEN -->
  <section id="search-screen" class="screen visible">
    <h2>Поиск собеседника…</h2>
    <div id="search-status">Ожидание другого пользователя</div>
    <button id="cancelSearch">Отменить</button>
  </section>

  <!-- CHAT WINDOW -->
  <section id="chat-window" class="screen">
    <div id="messages"></div>

    <div id="chatInput">
      <input id="chatText" type="text" placeholder="Введите сообщение…" />
      <button id="sendMessage">Отправить</button>
    </div>

    <button id="finishBtn">Завершить чат</button>
  </section>

  <!-- END SCREEN -->
  <section id="end-screen" class="screen">
    <h2 id="statusText">Чат завершён</h2>
    <button id="newChatBtn">Новый чат</button>
  </section>

</main>

<!-- FINISH MODAL -->
<div id="finishModal" class="hidden">
  <div id="finishModalContent">
    <p>Завершить чат?</p>
    <button id="modalFinish">Да</button>
    <button id="modalCancel">Отмена</button>
  </div>
</div>

<script type="module">

// Firebase SDK
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-app.js";
import {
  getAuth,
  onAuthStateChanged,
  signInAnonymously
} from "https://www.gstatic.com/firebasejs/10.13.0/firebase-auth.js";

import {
  getFirestore,
  doc,
  setDoc,
  getDoc,
  updateDoc,
  addDoc,
  serverTimestamp,
  collection,
  deleteDoc,
  onSnapshot,
  query,
  orderBy,
  runTransaction,
  getDocs,
  Timestamp
} from "https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore.js";


const firebaseConfig = {
  apiKey: "AIzaSyD1...",
  authDomain: "private-chat.firebaseapp.com",
  projectId: "private-chat",
  storageBucket: "private-chat.appspot.com",
  messagingSenderId: "000000",
  appId: "1:000000:web:0000000"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);


let uid = null;               // уникальный идентификатор (firebase или guest)
let isGuest = false;          // true → если анонимная авторизация НЕ удалась
let userAvatar = null;        // base64 или URL
let roomRef = null;
let roomId = null;
let partnerId = null;

let messagesUnsub = null;
let roomUnsub = null;
let presenceUnsub = null;
let waitingUnsub = null;
let myWaitingUnsub = null;
let presenceHeartbeatInterval = null;


const searchScreen = document.getElementById('search-screen');
const chatWindow = document.getElementById('chat-window');
const endScreen = document.getElementById('end-screen');
const statusText = document.getElementById('statusText');
const messagesEl = document.getElementById('messages');

const chatText = document.getElementById('chatText');
const sendMessageBtn = document.getElementById('sendMessage');

const finishBtn = document.getElementById('finishBtn');
const newChatBtn = document.getElementById('newChatBtn');
const cancelSearch = document.getElementById('cancelSearch');
const exitBtn = document.getElementById('exitBtn');

const modal = document.getElementById('finishModal');
const modalFinish = document.getElementById('modalFinish');
const modalCancel = document.getElementById('modalCancel');


function show(el){ el.classList.add('visible'); }
function hide(el){ el.classList.remove('visible'); }

function randomUid() {
  return "guest_" + Math.random().toString(36).slice(2);
}


function loadAvatar() {
  const saved = localStorage.getItem("userAvatar");
  if (saved) {
    userAvatar = saved;
  }
}

function saveAvatar(base64) {
  userAvatar = base64;
  localStorage.setItem("userAvatar", base64);
}



async function initAuth() {
  return new Promise(resolve => {

    onAuthStateChanged(auth, async user => {

      if (user) {
        // Успешный Firebase авторизованный пользователь
        uid = user.uid;
        isGuest = false;
        loadAvatar();
        resolve();
        return;
      }

      // Если нет авторизации — пробуем анонимную
      try {
        const cred = await signInAnonymously(auth);
        uid = cred.user.uid;
        isGuest = false;
        loadAvatar();
        resolve();
      } catch (err) {
        console.warn("Анонимная авторизация не удалась:", err);

        // Создаём локального пользователя — гостя
        uid = randomUid();
        isGuest = true;
        loadAvatar();
        resolve();
      }

    });

  });
}

await initAuth();


/* === Константы === */
const WAITING_TIMEOUT = 30000; // 30 сек
const PRESENCE_PING_INTERVAL = 5000;
const PRESENCE_STALE_MS = 15000;


/* === Состояние поиска === */
let myWaitingRef = null;
let myWaitingUnsub = null;
let waitingUnsub = null;
let waitingHeartbeatInterval = null;


function addMessageToUI(msg) {
  const div = document.createElement("div");
  const mine = msg.sender === uid;

  div.className = mine ? "my-msg" : "partner-msg";

  div.innerHTML = msg.text;
  messagesEl.appendChild(div);
  messagesEl.scrollTop = messagesEl.scrollHeight;
}


sendMessageBtn.addEventListener("click", sendMsg);
chatText.addEventListener("keydown", e => {
  if (e.key === "Enter") sendMsg();
});

async function sendMsg() {
  const text = chatText.value.trim();
  if (!text || !roomRef) return;

  chatText.value = "";

  try {
    await addDoc(collection(roomRef, "messages"), {
      text,
      sender: uid,
      createdAt: serverTimestamp()
    });
  } catch (e) {
    console.warn("send error:", e);
  }
}


function startSearch() {
  hide(chatWindow);
  hide(endScreen);
  show(searchScreen);

  searchForPartner();
}


async function searchForPartner() {
  const waitingCol = collection(db, "waiting");
  myWaitingRef = doc(waitingCol);

  const startTime = Date.now();

  await setDoc(myWaitingRef, {
    uid,
    created: serverTimestamp(),
    claimed: false
  });

  myWaitingUnsub = onSnapshot(myWaitingRef, async snap => {
    if (!snap.exists()) return;

    const data = snap.data();

    if (data.claimed && data.room) {
      // меня подобрали
      roomId = data.room;
      roomRef = doc(db, "rooms", roomId);
      partnerId = data.partner;

      stopWaitingHeartbeat();
      if (waitingUnsub) waitingUnsub();

      joinRoom();
    }
  });

  // мониторим всех ожидающих (кроме себя)
  const q = query(waitingCol, orderBy("created"));
  waitingUnsub = onSnapshot(q, async snap => {
    const docs = snap.docs;

    for (const d of docs) {
      if (d.id === myWaitingRef.id) continue;
      const w = d.data();

      if (!w.claimed) {
        // пытаемся забрать
        try {
          await runTransaction(db, async txn => {
            const targetSnap = await txn.get(d.ref);
            if (!targetSnap.exists()) return;

            const target = targetSnap.data();
            if (target.claimed) return;

            const newRoom = doc(collection(db, "rooms"));
            txn.set(newRoom, {
              participants: [uid, target.uid],
              created: serverTimestamp(),
              closed: false
            });

            txn.update(myWaitingRef, {
              claimed: true,
              room: newRoom.id,
              partner: target.uid
            });

            txn.update(d.ref, {
              claimed: true,
              room: newRoom.id,
              partner: uid
            });
          });

          return;
        } catch (e) {
          console.warn("claim failed", e);
        }
      }
    }

    // timeout — начать поиск заново
    if (Date.now() - startTime > WAITING_TIMEOUT) {
      await deleteDoc(myWaitingRef).catch(() => {});
      if (myWaitingUnsub) myWaitingUnsub();
      if (waitingUnsub) waitingUnsub();
      startSearch();
    }
  });

  // heartbeat для waiting
  waitingHeartbeatInterval = setInterval(async () => {
    if (!myWaitingRef) return;
    try {
      await updateDoc(myWaitingRef, { created: serverTimestamp() });
    } catch {}
  }, 5000);
}

function stopWaitingHeartbeat() {
  if (waitingHeartbeatInterval) clearInterval(waitingHeartbeatInterval);
  waitingHeartbeatInterval = null;
}


async function joinRoom() {
  hide(searchScreen);
  hide(endScreen);
  show(chatWindow);

  messagesEl.innerHTML = "";

  // слушаем сообщения
  const msgsCol = collection(roomRef, "messages");
  const q = query(msgsCol, orderBy("createdAt"));

  messagesUnsub = onSnapshot(q, snap => {
    messagesEl.innerHTML = "";
    snap.forEach(doc => addMessageToUI(doc.data()));
  });

  // presence
  await setMyPresence();

  const presCol = collection(roomRef, "presence");
  presenceUnsub = onSnapshot(presCol, async snap => {
    const now = Date.now();

    const alive = snap.docs.filter(d => {
      const ls = d.data().lastSeen;
      if (!ls) return false;

      const t = ls.toMillis
        ? ls.toMillis()
        : new Date(ls).getTime();

      return now - t < PRESENCE_STALE_MS;
    });

    // если оба вышли — удаляем комнату
    if (alive.length === 0) {
      try {
        await fullRoomCleanup();
      } catch {}
    }
  });
}


async function setMyPresence() {
  if (!roomRef || !uid) return;

  const pRef = doc(roomRef, "presence", uid);

  try {
    await setDoc(pRef, { lastSeen: serverTimestamp() });
  } catch {}

  if (presenceHeartbeatInterval)
    clearInterval(presenceHeartbeatInterval);

  presenceHeartbeatInterval = setInterval(async () => {
    try {
      await updateDoc(pRef, { lastSeen: serverTimestamp() });
    } catch {}
  }, PRESENCE_PING_INTERVAL);
}


finishBtn.addEventListener("click", () => {
  modal.classList.remove("hidden");
});
modalCancel.addEventListener("click", () => {
  modal.classList.add("hidden");
});
modalFinish.addEventListener("click", async () => {
  modal.classList.add("hidden");
  await finishChat();
});

async function finishChat() {
  if (roomRef) {
    try {
      await updateDoc(roomRef, { closed: true });
      await fullRoomCleanup();
    } catch {}
  }

  connectedCleanup();
  show(endScreen);
  hide(chatWindow);
  statusText.textContent = "Чат завершён";
}


newChatBtn.addEventListener("click", async () => {
  await fullRoomCleanup();
  await clearAllState();
  startSearch();
});

exitBtn.addEventListener("click", async e => {
  e.preventDefault();
  await fullRoomCleanup();
  await clearAllState();
  window.location.href = "/anonymous/";
});


function connectedCleanup() {
  if (messagesUnsub) messagesUnsub();
  if (roomUnsub) roomUnsub();
  if (presenceUnsub) presenceUnsub();
  if (presenceHeartbeatInterval) clearInterval(presenceHeartbeatInterval);
}

async function fullRoomCleanup() {
  if (!roomRef) return;

  try {
    const r = await getDoc(roomRef);
    if (!r.exists()) return;

    const data = r.data();
    const participants = data.participants || [];

    const newParts = participants.filter(p => p !== uid);

    if (newParts.length === 0) {
      const msgs = await getDocs(collection(roomRef, "messages"));
      msgs.forEach(m => deleteDoc(m.ref).catch(() => {}));

      const pres = await getDocs(collection(roomRef, "presence"));
      pres.forEach(p => deleteDoc(p.ref).catch(() => {}));

      await deleteDoc(roomRef).catch(() => {});
    } else {
      await updateDoc(roomRef, { participants: newParts }).catch(() => {});
    }
  } catch (e) {}
}


async function clearAllState() {
  connectedCleanup();
  stopWaitingHeartbeat();

  if (myWaitingRef) {
    try {
      await deleteDoc(myWaitingRef).catch(() => {});
    } catch {}
    myWaitingRef = null;
  }

  roomRef = null;
  roomId = null;
  partnerId = null;
  messagesEl.innerHTML = "";
}

startSearch();

</script>

</body>
</html>
